import sqlite3
import tkinter as tk
from tkinter import messagebox, font
import attendee as at
import administrator as ad
import database as db
import re

def main():
    # Connect to the database
    db.connect('test.db')
    db.init()

    root = tk.Tk()
    root.title("Banquet Management System")
    root.geometry("400x300")

    def open_attendee_login():
        attendee_login_window = tk.Toplevel(root)
        attendee_login_window.title("Attendee Login")
        attendee_login_window.geometry("300x250")  # 调整窗口高度来容纳新按钮

        # 设置邮箱输入框
        tk.Label(attendee_login_window, text="Email:", font=("Avenir", 12)).pack(pady=5)
        email_entry = tk.Entry(attendee_login_window, font=("Avenir", 12))
        email_entry.pack()

        # 设置密码输入框
        tk.Label(attendee_login_window, text="Password:", font=("Avenir", 12)).pack(pady=5)
        password_entry = tk.Entry(attendee_login_window, show="*", font=("Avenir", 12))
        password_entry.pack()

        # 登录功能
        def attendee_login():
            email = email_entry.get()
            password = password_entry.get()

            # 调用登录逻辑，这里需要根据实际情况来验证用户信息
            success = at.login(email, password)
            if success:
                messagebox.showinfo("Login Successful", f"Welcome, {email}!")
                attendee_login_window.destroy()  # 关闭登录窗口
                attendee_main_menu()  # 打开参会者的主菜单
            else:
                messagebox.showerror("Login Failed", "Invalid email or password.")  # 登录失败提示

        # 登录按钮
        login_button = tk.Button(attendee_login_window, text="Login", font=("Avenir", 12), command=attendee_login)
        login_button.pack(pady=10)

        # 注册按钮
        def open_register_window():
            attendee_login_window.destroy()  # 关闭当前登录窗口
            open_attendee_register()  # 打开注册窗口

        register_button = tk.Button(attendee_login_window, text="Register", font=("Avenir", 12),
                                    command=open_register_window)
        register_button.pack(pady=10)

    # Function to open Attendee Login Window
    def open_attendee_register():
        attendee_register_window = tk.Toplevel(root)
        attendee_register_window.title("Attendee Registration")
        attendee_register_window.geometry("300x600")

        # Create input fields for attendee registration
        tk.Label(attendee_register_window, text="First Name:", font=("Avenir", 12)).pack(pady=5)
        first_name_entry = tk.Entry(attendee_register_window, font=("Avenir", 12))
        first_name_entry.pack()

        tk.Label(attendee_register_window, text="Last Name:", font=("Avenir", 12)).pack(pady=5)
        last_name_entry = tk.Entry(attendee_register_window, font=("Avenir", 12))
        last_name_entry.pack()

        tk.Label(attendee_register_window, text="Email:", font=("Avenir", 12)).pack(pady=5)
        email_entry = tk.Entry(attendee_register_window, font=("Avenir", 12))
        email_entry.pack()

        tk.Label(attendee_register_window, text="Phone Number:", font=("Avenir", 12)).pack(pady=5)
        phone_entry = tk.Entry(attendee_register_window, font=("Avenir", 12))
        phone_entry.pack()

        tk.Label(attendee_register_window, text="Password:", font=("Avenir", 12)).pack(pady=5)
        password_entry = tk.Entry(attendee_register_window, show="*", font=("Avenir", 12))
        password_entry.pack()

        tk.Label(attendee_register_window, text="Confirm Password:", font=("Avenir", 12)).pack(pady=5)
        confirm_password_entry = tk.Entry(attendee_register_window, show="*", font=("Avenir", 12))
        confirm_password_entry.pack()

        tk.Label(attendee_register_window, text="Affiliated Organization:", font=("Avenir", 12)).pack(pady=5)
        organization_entry = tk.Entry(attendee_register_window, font=("Avenir", 12))
        organization_entry.pack()

        def register_attendee():
            # Collect input data
            first_name = first_name_entry.get()
            last_name = last_name_entry.get()
            email = email_entry.get()
            phone = phone_entry.get()
            password = password_entry.get()
            confirm_password = confirm_password_entry.get()
            organization = organization_entry.get()

            # Create the account dictionary
            account = {
                'AttendeeID': None,  # Will be auto-generated by the database
                'FirstName': first_name,
                'LastName': last_name,
                'Email': email,
                'MobileNumber': phone,
                'Password': password,
                'AttendeeType': 'Regular',  # You can change the type as needed
                'Address': 'Not Provided',  # You can add an address field if necessary
                'AffiliatedOrganization': organization
            }

            # Validate inputs using check() function
            is_valid = at.check(account)  # Check function only returns a boolean

            if not is_valid:
                # If check() returns False, manually collect and show errors
                error_message = "\n".join([
                    "Invalid email format.",
                    "",
                    "Mobile number MUST be an 8-digit number.",
                    "",
                    "First and last names must contain only alphabetic characters."
                ])  # Replace with actual error messages or improve error handling
                messagebox.showerror("Registration Failed",
                                     f"Please check your input. Some fields are incorrect:\n\n{error_message}")
                return

            # Validate password
            if password != confirm_password:
                messagebox.showerror("Error", "Passwords do not match!")
                return

            # Register the attendee (calls the `newAccount` function)
            success = at.newAccount(account)
            if success:
                messagebox.showinfo("Registration Successful", "You have registered successfully. You can now log in.")
                attendee_register_window.destroy()
                open_attendee_login()  # Open the login window after registration
            else:
                messagebox.showerror("Registration Failed", "An error occurred during registration.")

        # Register button
        register_button = tk.Button(attendee_register_window, text="Register", font=("Avenir", 12),
                                    command=register_attendee)
        register_button.pack(pady=20)

    # Function to open Administrator Login Window
    def open_admin_login():
        admin_login_window = tk.Toplevel(root)
        admin_login_window.title("Administrator Login")
        admin_login_window.geometry("300x200")

        tk.Label(admin_login_window, text="Username:", font=("Avenir", 12)).pack(pady=5)
        username_entry = tk.Entry(admin_login_window, font=("Avenir", 12))
        username_entry.pack()

        tk.Label(admin_login_window, text="Password:", font=("Avenir", 12)).pack(pady=5)
        password_entry = tk.Entry(admin_login_window, show="*", font=("Avenir", 12))
        password_entry.pack()

        def admin_login():
            username = username_entry.get()
            password = password_entry.get()
            success = ad.login(username, password)
            if success:
                messagebox.showinfo("Login Successful", f"{username} logged in successfully.")
                admin_login_window.destroy()
                admin_main_menu()
            else:
                messagebox.showerror("Login Failed", "Invalid username or password.")

        login_button = tk.Button(admin_login_window, text="Login", font=("Avenir", 12), command=admin_login)
        login_button.pack(pady=10)

    def attendee_main_menu():
        attendee_menu_window = tk.Toplevel(root)
        attendee_menu_window.title("Attendee Menu")
        attendee_menu_window.geometry("400x300")

        tk.Label(attendee_menu_window, text="Welcome, Attendee!", font=("Avenir", 16)).pack(pady=10)

        # Function buttons with improved binding and layout
        buttons = [
            ("Register for Banquet", register_banquet),
            ("Update Registration", update_registration),
            ("Search Banquets", search_banquets),
            ("Logout", lambda: logout(attendee_menu_window))
        ]

        for text, command in buttons:
            button = tk.Button(attendee_menu_window, text=text, font=("Avenir", 12), command=command)
            button.pack(pady=5)

    def register_banquet():
        register_window = tk.Toplevel(root)
        register_window.title("Register for Banquet")
        register_window.geometry("400x400")

        # Fetch available banquet options from the database
        try:
            db.connect('test.db')  # Ensure the connection is established
            db.init()
            c = db.c
            c.execute("SELECT Bin, BanquetName, Available FROM Banquet WHERE Available = 'Y'")
            banquet_records = c.fetchall()

            # Create a list of available banquet options
            banquet_options = [
                f"{bin_number} - {banquet_name} ({'Yes' if available == 'Y' else 'No'})"
                for bin_number, banquet_name, available in banquet_records
            ]

            # If no available banquets, show a message and close window
            if not banquet_options:
                messagebox.showinfo("Info", "No available banquets to register.")
                register_window.destroy()
                return

        except sqlite3.Error as e:
            messagebox.showerror("Database Error", f"An error occurred while fetching banquet data: {e}")
            register_window.destroy()
            return

        # Initialize Tkinter variable for the banquet selection
        banquet_var = tk.StringVar(register_window)
        banquet_var.set(banquet_options[0])  # Set default option to the first banquet

        # Create an OptionMenu to display the banquet choices
        banquet_menu = tk.OptionMenu(register_window, banquet_var, *banquet_options)
        banquet_menu.config(font=("Avenir", 12))
        banquet_menu.pack(pady=10)

        # Create other input fields for meal choice, drink choice, and remarks
        meal_choice_entry = tk.Entry(register_window, font=("Avenir", 12))
        drink_choice_entry = tk.Entry(register_window, font=("Avenir", 12))
        remarks_entry = tk.Entry(register_window, font=("Avenir", 12))

        tk.Label(register_window, text="Meal Choice:", font=("Avenir", 12)).pack()
        meal_choice_entry.pack(pady=5)

        tk.Label(register_window, text="Drink Choice:", font=("Avenir", 12)).pack()
        drink_choice_entry.pack(pady=5)

        tk.Label(register_window, text="Remarks:", font=("Avenir", 12)).pack()
        remarks_entry.pack(pady=5)

        def submit_registration():
            selected_banquet = banquet_var.get()
            if not selected_banquet:
                messagebox.showerror("Error", "Please select a banquet.")
                return

            # Extract the Bin number from the selected banquet option
            try:
                bin_number = int(selected_banquet.split(" - ")[0])  # Get the Bin number from the string
            except ValueError:
                messagebox.showerror("Error", "Invalid banquet selection.")
                return

            # Get the meal, drink, and remarks input from the user
            meal_choice = meal_choice_entry.get()
            drink_choice = drink_choice_entry.get()
            remarks = remarks_entry.get()

            # Use the current date or any other logic for registration time
            registration_time = "2024-11-12"  # You can replace this with dynamic current date if needed

            # Call the registration function to submit the data
            try:
                success = at.registration(registration_time, bin_number, meal_choice, drink_choice, remarks)
                if success:
                    messagebox.showinfo("Success", "Registration successful.")
                    register_window.destroy()  # Close the window after successful registration
                else:
                    messagebox.showerror("Error", "Registration failed.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred during registration: {e}")

        # Register button to submit the form
        submit_button = tk.Button(register_window, text="Register", font=("Avenir", 12), command=submit_registration)
        submit_button.pack(pady=20)

    def search_banquets():
        search_window = tk.Toplevel(root)
        search_window.title("Search Banquets")
        search_window.geometry("400x400")

        tk.Label(search_window, text="Search Criteria", font=("Avenir", 12)).pack(pady=10)

        tk.Label(search_window, text="Date (YYYY-MM-DD):", font=("Avenir", 12)).pack()
        date_entry = tk.Entry(search_window, font=("Avenir", 12))
        date_entry.pack()

        tk.Label(search_window, text="Banquet Name:", font=("Avenir", 12)).pack()
        name_entry = tk.Entry(search_window, font=("Avenir", 12))
        name_entry.pack()

        def perform_search():
            criteria = {}
            if date_entry.get():
                criteria['date'] = date_entry.get()
            if name_entry.get():
                criteria['banquetName'] = name_entry.get()

            results = at.search(criteria)
            if results:
                results_window = tk.Toplevel(root)
                results_window.title("Search Results")
                results_window.geometry("500x400")

                for banquet in results:
                    banquet_info = f"{banquet['name']} on {banquet['date']} at {banquet['time']}"
                    tk.Label(results_window, text=banquet_info, font=("Avenir", 12)).pack()
            else:
                messagebox.showinfo("No Results", "No banquets found matching the criteria.")

        search_button = tk.Button(search_window, text="Search", font=("Avenir", 12), command=perform_search)
        search_button.pack(pady=10)

    def update_registration():
        update_window = tk.Toplevel(root)
        update_window.title("Update Registration")
        update_window.geometry("400x300")

        tk.Label(update_window, text="Registration ID:", font=("Avenir", 12)).pack()
        reg_id_entry = tk.Entry(update_window, font=("Avenir", 12))
        reg_id_entry.pack()

        tk.Label(update_window, text="Field to Update:", font=("Avenir", 12)).pack()
        field_var = tk.StringVar()
        field_var.set("Select Field")
        fields = ['MealChoice', 'DrinkChoice', 'Remarks']
        field_menu = tk.OptionMenu(update_window, field_var, *fields)
        field_menu.config(font=("Avenir", 12))
        field_menu.pack()

        tk.Label(update_window, text="New Value:", font=("Avenir", 12)).pack()
        new_value_entry = tk.Entry(update_window, font=("Avenir", 12))
        new_value_entry.pack()

        def submit_update():
            reg_id = reg_id_entry.get()
            field = field_var.get()
            new_value = new_value_entry.get()
            if not reg_id or field == "Select Field" or not new_value:
                messagebox.showerror("Error", "Please fill in all fields.")
                return

            success = at.updateRegistration(reg_id, field, new_value)
            if success:
                messagebox.showinfo("Success", "Registration updated successfully.")
                update_window.destroy()
            else:
                messagebox.showerror("Error", "Failed to update registration.")

        update_button = tk.Button(update_window, text="Update", font=("Avenir", 12), command=submit_update)
        update_button.pack(pady=10)

    def admin_main_menu():
        admin_menu_window = tk.Toplevel(root)
        admin_menu_window.title("Administrator Menu")
        admin_menu_window.geometry("400x300")

        tk.Label(admin_menu_window, text=f"Welcome, Administrator!", font=("Avenir", 16)).pack(pady=10)

        # 绑定各个按钮到相应的函数
        create_button = tk.Button(admin_menu_window, text="Create Banquet", font=("Avenir", 12), command=create_banquet)
        update_button = tk.Button(admin_menu_window, text="Update Banquet", font=("Avenir", 12), command=update_banquet)
        report_button = tk.Button(admin_menu_window, text="Generate Reports", font=("Avenir", 12), command=generate_reports)
        logout_button = tk.Button(admin_menu_window, text="Logout", font=("Avenir", 12), command=lambda: logout(admin_menu_window))

        create_button.pack(pady=5)
        update_button.pack(pady=5)
        report_button.pack(pady=5)
        logout_button.pack(pady=5)

    def create_banquet():
        try:
            create_window = tk.Toplevel(root)
            create_window.title("Create Banquet")
            create_window.geometry("400x600")

            # Banquet details
            banquet_fields = {
                'name': tk.Entry(create_window, font=("Avenir", 12)),
                'date': tk.Entry(create_window, font=("Avenir", 12)),
                'time': tk.Entry(create_window, font=("Avenir", 12)),
                'address': tk.Entry(create_window, font=("Avenir", 12)),
                'location': tk.Entry(create_window, font=("Avenir", 12)),
                'contact_staff': tk.Entry(create_window, font=("Avenir", 12)),
                'quota': tk.Entry(create_window, font=("Avenir", 12)),
            }

            # Change the 'available' field to an Entry widget
            banquet_fields['available'] = tk.Entry(create_window, font=("Avenir", 12))

            # Define field examples for format instructions
            field_examples = {
                'name': "(e.g. Gala Dinner)",
                'date': "(e.g. 2024-12-25)",
                'time': "(e.g. 18:00)",
                'address': "(e.g. 123 Event St, City)",
                'location': "(e.g. Main Hall)",
                'contact_staff': "(e.g. John Doe)",
                'available': "(Y or N)",
                'quota': "(e.g. 100)"
            }

            # Packing the fields with example format
            for field, entry in banquet_fields.items():
                tk.Label(create_window, text=f"{field.capitalize()} {field_examples[field]}",
                         font=("Avenir", 12)).pack()
                entry.pack()

            # Meals
            meals = []

            def add_meal():
                meal_window = tk.Toplevel(root)
                meal_window.title("Add Meal")
                meal_window.geometry("300x300")

                meal_fields = {
                    'dish_name': tk.Entry(meal_window, font=("Avenir", 12)),
                    'meal_type': tk.Entry(meal_window, font=("Avenir", 12)),
                    'price': tk.Entry(meal_window, font=("Avenir", 12)),
                    'special_cuisine': tk.Entry(meal_window, font=("Avenir", 12))
                }

                # Add format examples for each meal field
                meal_field_examples = {
                    'dish_name': "(e.g. Roast Chicken)",
                    'meal_type': "(e.g. Main Course)",
                    'price': "(e.g. 25.50)",
                    'special_cuisine': "(e.g. Gluten-free)"
                }

                for field, entry in meal_fields.items():
                    tk.Label(meal_window, text=f"{field.replace('_', ' ').capitalize()} {meal_field_examples[field]}",
                             font=("Avenir", 12)).pack()
                    entry.pack()

                def save_meal():
                    try:
                        # Collect meal details
                        meal = {field: entry.get() for field, entry in meal_fields.items()}

                        # Check if any field is empty
                        if any(not meal[field] for field in meal_fields):
                            messagebox.showerror("Error", "All meal fields must be filled!")
                            return  # Exit if any field is empty

                        meals.append(meal)
                        messagebox.showinfo("Success", "Meal added successfully.")

                        # Reset the meal fields for the next meal
                        for field, entry in meal_fields.items():
                            entry.delete(0, tk.END)  # Clear the entry fields for the next meal

                        add_meal_button.config(state=tk.NORMAL)  # Re-enable the "Add Meal" button if needed

                    except Exception as e:
                        print(f"Error in save_meal: {e}")
                        messagebox.showerror("Error", f"An error occurred: {e}")

                save_button = tk.Button(meal_window, text="Save Meal", font=("Avenir", 12), command=save_meal)
                save_button.pack(pady=10)

            add_meal_button = tk.Button(create_window, text="Add Meal", font=("Avenir", 12), command=add_meal)
            add_meal_button.pack(pady=10)

            def submit_banquet():
                try:
                    banquet = {field: entry.get() for field, entry in banquet_fields.items()}
                    # Convert 'available' to 'Y' or 'N' and 'quota' to an integer
                    available_value = banquet['available'].strip().upper()
                    if available_value not in ['Y', 'N']:
                        messagebox.showerror("Error", "Available must be 'Y' or 'N'!")
                        return

                    banquet['available'] = available_value
                    banquet['quota'] = int(banquet['quota'])

                    # Call the newBanquet function and get the BIN number
                    bin_number = ad.newBanquet(banquet, meals)

                    if bin_number:
                        # Show the BIN number in the success message box
                        messagebox.showinfo("Success", f"Banquet created successfully. BIN: {bin_number}")
                        create_window.destroy()  # Close the create window
                    else:
                        messagebox.showerror("Error", "Failed to create banquet.")
                except Exception as e:
                    print(f"Error in submit_banquet: {e}")
                    messagebox.showerror("Error", f"An error occurred: {e}")

            submit_button = tk.Button(create_window, text="Create Banquet", font=("Avenir", 12), command=submit_banquet)
            submit_button.pack(pady=10)

        except Exception as e:
            print(f"Error in create_banquet: {e}")  # Debug print
            messagebox.showerror("Error", f"An error occurred: {e}")

    def update_banquet():
        update_window = tk.Toplevel(root)
        update_window.title("Update Banquet")
        update_window.geometry("400x300")

        tk.Label(update_window, text="Banquet ID (Bin):", font=("Avenir", 12)).pack()
        bin_entry = tk.Entry(update_window, font=("Avenir", 12))
        bin_entry.pack()

        tk.Label(update_window, text="Field to Update:", font=("Avenir", 12)).pack()
        field_var = tk.StringVar()
        field_var.set("Select Field")
        fields = ['BanquetName', 'Date', 'Time', 'Address', 'Location', 'ContactStaffName', 'Available', 'Quota']
        field_menu = tk.OptionMenu(update_window, field_var, *fields)
        field_menu.config(font=("Avenir", 12))
        field_menu.pack()

        tk.Label(update_window, text="New Value:", font=("Avenir", 12)).pack()
        new_value_entry = tk.Entry(update_window, font=("Avenir", 12))
        new_value_entry.pack()

        def submit_update():
            bin_number = bin_entry.get()
            field = field_var.get()
            new_value = new_value_entry.get()
            if not bin_number or field == "Select Field" or not new_value:
                messagebox.showerror("Error", "Please fill in all fields.")
                return

            # Convert available and quota to integers if necessary
            if field in ['Available', 'Quota']:
                new_value = int(new_value)

            success = ad.updBanquet(int(bin_number), field, new_value)
            if success:
                messagebox.showinfo("Success", "Banquet updated successfully.")
                update_window.destroy()
            else:
                messagebox.showerror("Error", "Failed to update banquet.")

        update_button = tk.Button(update_window, text="Update Banquet", font=("Avenir", 12), command=submit_update)
        update_button.pack(pady=10)

    def generate_reports():
        success = ad.report()
        if success:
            # Generate the report and display in a new window
            report_window = tk.Toplevel(root)
            report_window.title("Generated Report")
            report_window.geometry("500x400")

            # Get the report content (using ad.report() to retrieve details)
            report_content = ad.get_report_content()  # We'll implement this in administrator.py

            # Display the report in a Text widget
            report_text = tk.Text(report_window, wrap=tk.WORD, font=("Avenir", 12))
            report_text.insert(tk.END, report_content)
            report_text.pack(expand=True, fill=tk.BOTH)

            # Optionally, add a scrollbar if the content is large
            scrollbar = tk.Scrollbar(report_window, command=report_text.yview)
            report_text.config(yscrollcommand=scrollbar.set)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        else:
            messagebox.showerror("Error", "Failed to generate report.")

    def logout(menu_window):
        global AID
        AID = None
        menu_window.destroy()
        print("Logged out successfully.")  # 调试信息

    # Create buttons on the main window
    attendee_login_button = tk.Button(root, text="Attendee Login", font=("Avenir", 12), command=open_attendee_login)
    admin_login_button = tk.Button(root, text="Administrator Login", font=("Avenir", 12), command=open_admin_login)

    attendee_login_button.pack(pady=20)
    admin_login_button.pack(pady=20)

    root.mainloop()
    db.close()

if __name__ == "__main__":
    main()
